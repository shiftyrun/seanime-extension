{"id":"anime-sama-online-streaming","name":"FR | Anime Sama","version":"3.0.0","manifestURI":"https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/anime-sama/manifest.json","language":"typescript","type":"onlinestream-provider","description":"Anime Sama est une extension Seanime en fran√ßais qui permet de regarder des anime dans le catalogue du site anime-sama.com.","author":"TropicalFrog3","icon":"https://raw.githubusercontent.com/TropicalFrog3/seanime-extension/refs/heads/main/online-streaming/anime-sama/favicon.png","website":"","lang":"fr","payload":"/// \u003creference path=\"../_external/.onlinestream-provider.d.ts\" /\u003e\n/// \u003creference path=\"../_external/core.d.ts\" /\u003e\n\nconst DevMode = true;\nconst originalConsoleLog = console.log;\nconsole.log = function (...args: any[]) {\n    if (DevMode) {\n        originalConsoleLog.apply(console, args);\n    }\n};\n\nclass Provider {\n    readonly BASE_URL = \"https://anime-sama.si\";\n    readonly CATALOGUE_URL = \"https://anime-sama.si/catalogue/\";\n    readonly SEANIME_API = \"http://127.0.0.1:43211/api/v1/proxy?url=\";\n\n    private readonly VOICES_VALUES = [\"vostfr\", \"vf\", \"vf1\", \"vf2\", \"va\", \"vcn\", \"vj\", \"vkr\", \"vqc\"];\n    private readonly SUPPORTED_SERVERS = [\"sibnet\", \"vk\", \"sendvid\", \"vidmoly\", \"movearnpre\", \"oneupload\"];\n\n    _Server = \"\";\n\n    getSettings(): Settings {\n        return {\n            episodeServers: this.SUPPORTED_SERVERS,\n            supportsDub: true,\n        };\n    }\n\n    private async fetchAnimeSeasons(animeUrl: string): Promise\u003cany[]\u003e {\n        try {\n            const response = await fetch(`${this.SEANIME_API}${encodeURIComponent(animeUrl)}`);\n            if (!response.ok) return [];\n            \n            const html = await response.text();\n            const $ = await LoadDoc(html);\n            \n            const animeName = $(\"#titreOeuvre\").text() || \"\";\n            const thumbnail = $(\"#coverOeuvre\").attr(\"src\") || \"\";\n            const description = $(\"h2:contains(synopsis)\").next(\"p\").text() || \"\";\n            const genre = $(\"h2:contains(genres)\").next(\"a\").text() || \"\";\n\n            const scripts = $(\"h2\").next(\"p\").next(\"div\").find(\"script\").text() || \n                           $(\"h2\").next(\"div\").find(\"script\").text() || \"\";\n            \n            const uncommented = scripts.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n            const seasonRegex = /^\\s*panneauAnime\\(\"([^\"]+)\",\\s*\"([^\"]+)\"\\)/gm;\n            \n            const seasons: any[] = [];\n            let match;\n            \n            while ((match = seasonRegex.exec(uncommented)) !== null) {\n                const [, seasonName, seasonStem] = match;\n                \n                if (seasonStem.includes(\"film\")) {\n                    const moviesUrl = `${animeUrl}/${seasonStem}`;\n                    const moviePlayers = await this.fetchPlayers(moviesUrl);\n                    \n                    if (moviePlayers.length \u003e 0) {\n                        const movieResponse = await fetch(`${this.SEANIME_API}${encodeURIComponent(moviesUrl)}`);\n                        if (movieResponse.ok) {\n                            const movieHtml = await movieResponse.text();\n                            const movieNameRegex = /^\\s*newSPF\\(\"([^\"]+)\"\\)/gm;\n                            const movieNames: string[] = [];\n                            let nameMatch;\n                            \n                            while ((nameMatch = movieNameRegex.exec(movieHtml)) !== null) {\n                                movieNames.push(nameMatch[1]);\n                            }\n                            \n                            for (let i = 0; i \u003c moviePlayers.length; i++) {\n                                const title = movieNames.length \u003e i ? \n                                    `${animeName} ${movieNames[i]}` : \n                                    moviePlayers.length === 1 ? `${animeName} Film` : `${animeName} Film ${i + 1}`;\n                                \n                                seasons.push({\n                                    title,\n                                    url: `${moviesUrl}#${i}`,\n                                    status: \"COMPLETED\",\n                                    thumbnail,\n                                    description,\n                                    genre\n                                });\n                            }\n                        }\n                    }\n                } else {\n                    seasons.push({\n                        title: `${animeName} ${seasonName}`,\n                        url: `${animeUrl}/${seasonStem}`,\n                        status: \"UNKNOWN\",\n                        thumbnail,\n                        description,\n                        genre\n                    });\n                }\n            }\n            \n            return seasons;\n        } catch (error) {\n            console.error(\"Error fetching anime seasons:\", error);\n            return [];\n        }\n    }\n\n    private async fetchPlayers(url: string): Promise\u003cany[]\u003e {\n        try {\n            const docUrl = `${url}/episodes.js`;\n            const response = await fetch(`${this.SEANIME_API}${encodeURIComponent(docUrl)}`);\n            \n            if (!response.ok) return [];\n            \n            const jsContent = await response.text();\n            const episodeArrays: string[][] = [];\n            \n            for (let i = 0; i \u003c 10; i++) {\n                const regex = new RegExp(`var\\\\s+eps${i}\\\\s*=\\\\s*\\\\[([\\\\s\\\\S]*?)\\\\];`, 'm');\n                const match = regex.exec(jsContent);\n                \n                if (match) {\n                    const urls = match[1]\n                        .split(',')\n                        .map(url =\u003e url.trim().replace(/['\"]/g, ''))\n                        .filter(url =\u003e url \u0026\u0026 url !== '');\n                    \n                    if (urls.length \u003e 0) {\n                        episodeArrays.push(urls);\n                    }\n                }\n            }\n            \n            if (episodeArrays.length === 0) return [];\n            \n            const maxEpisodes = Math.max(...episodeArrays.map(arr =\u003e arr.length));\n            const episodes: any[] = [];\n            \n            for (let episodeIndex = 0; episodeIndex \u003c maxEpisodes; episodeIndex++) {\n                const episodeUrls: string[] = [];\n                \n                for (const voiceArray of episodeArrays) {\n                    const url = voiceArray[episodeIndex];\n                    if (url) {\n                        const fixedUrl = url.replace(/vidmoly\\.to/g, 'vidmoly.net');\n                        episodeUrls.push(fixedUrl);\n                    }\n                }\n                \n                if (episodeUrls.length \u003e 0) {\n                    episodes.push(episodeUrls);\n                }\n            }\n            \n            return episodes;\n        } catch (error) {\n            console.error(\"Error fetching players:\", error);\n            return [];\n        }\n    }\n\n    private async HandleServerUrl(serverUrl: string): Promise\u003cVideoSource[]\u003e {\n        const req = await fetch(`${this.SEANIME_API}${encodeURIComponent(serverUrl)}`);\n        if (!req.ok) {\n            console.log(\"Failed to fetch server URL:\", serverUrl, \"Status:\", req.status);\n            return [];\n        }\n\n        const html = await req.text();\n\n        function unpack(p: string, a: number, c: number, k: string[]): string {\n            while (c--) {\n                if (k[c]) {\n                    p = p.replace(new RegExp('\\\\b' + c.toString(a) + '\\\\b', 'g'), k[c]);\n                }\n            }\n            return p;\n        }\n\n        let unpacked: string | undefined;\n        const scriptRegex = /\u003cscript[^\u003e]*\u003e([\\s\\S]*?)\u003c\\/script\u003e/gi;\n        let match;\n        \n        while ((match = scriptRegex.exec(html)) !== null) {\n            const script = match[1];\n            if (script.includes(\"eval(function(p,a,c,k,e,d)\")) {\n                const fullRegex = /eval\\(function\\([^)]*\\)\\{[\\s\\S]*?\\}\\(\\s*'([\\s\\S]*?)'\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*'([\\s\\S]*?)'\\.split\\('\\|'\\)/;\n                const unpackMatch = script.match(fullRegex);\n\n                if (unpackMatch) {\n                    const packed = unpackMatch[1];\n                    const base = parseInt(unpackMatch[2], 10);\n                    const count = parseInt(unpackMatch[3], 10);\n                    const dict = unpackMatch[4].split('|');\n\n                    unpacked = unpack(packed, base, count, dict);\n                    break;\n                }\n            }\n        }\n\n        // Look for video URLs\n        const m3u8Regex = /https?:\\/\\/[^\\s'\"]+\\.m3u8(?:\\?[^\\s'\"]*)?/g;\n        const mp4Regex = /https?:\\/\\/[^\\s'\"]+\\.mp4(?:\\?[^\\s'\"]*)?/g;\n        \n        let videoUrls: string[] = [];\n        const m3u8Matches = html.match(m3u8Regex);\n        const mp4Matches = html.match(mp4Regex);\n        \n        if (m3u8Matches) videoUrls = videoUrls.concat(m3u8Matches);\n        if (mp4Matches) videoUrls = videoUrls.concat(mp4Matches);\n        \n        if (unpacked) {\n            const unpackedM3u8 = unpacked.match(m3u8Regex);\n            const unpackedMp4 = unpacked.match(mp4Regex);\n            if (unpackedM3u8) videoUrls = videoUrls.concat(unpackedM3u8);\n            if (unpackedMp4) videoUrls = videoUrls.concat(unpackedMp4);\n        }\n\n        const videos: VideoSource[] = [];\n        for (const url of videoUrls) {\n            const type = url.includes('.m3u8') ? 'm3u8' : 'mp4';\n            videos.push({\n                url: url,\n                type: type as VideoSourceType,\n                quality: `${this._Server} - unknown`,\n                subtitles: []\n            });\n        }\n\n        return videos;\n    }\n\n    async search(opts: SearchOptions): Promise\u003cSearchResult[]\u003e {\n        let tempquery = opts.query;\n\n        const queryEnglish = opts.media.englishTitle || opts.query;\n        const seasonMatch = queryEnglish.toLowerCase().match(/season\\s*(\\d+)/i);\n        const seasonMatch2 = queryEnglish.toLowerCase().match(/(\\d+)/);\n\n        let seasonNumberOpts: number;\n        if (seasonMatch) {\n            seasonNumberOpts = parseInt(seasonMatch[1], 10);\n        } else {\n            seasonNumberOpts = seasonMatch2 ? parseInt(seasonMatch2[1], 10) : opts.media.format === \"TV\" ? 1 : -1;\n        }\n\n        while (tempquery !== \"\") {\n            console.log(`Searching for query: \"${tempquery}\".`);\n            \n            const searchUrl = new URL(this.CATALOGUE_URL);\n            searchUrl.searchParams.set(\"search\", tempquery);\n            searchUrl.searchParams.set(\"page\", \"1\");\n            \n            const response = await fetch(searchUrl.toString());\n            if (!response.ok) {\n                tempquery = tempquery.split(/[\\s:']+/).slice(0, -1).join(\" \");\n                continue;\n            }\n            \n            const html = await response.text();\n            const $ = await LoadDoc(html);\n            const searchResults = $(\"#list_catalog \u003e div a\");\n            \n            if (searchResults.length() \u003c= 0) {\n                tempquery = tempquery.split(/[\\s:']+/).slice(0, -1).join(\" \");\n                continue;\n            }\n\n            const firstResult = searchResults.first();\n            const animeUrl = firstResult.attr(\"href\");\n            \n            if (!animeUrl) {\n                return [];\n            }\n\n            console.log(\"Found anime URL:\", animeUrl);\n            \n            const seasons = await this.fetchAnimeSeasons(animeUrl);\n            \n            if (seasons.length === 0) {\n                return [];\n            }\n\n            let filteredSeasons = seasons.filter((season: any) =\u003e {\n                const seasonUrl = season.url;\n                \n                if (opts.media.format === \"MOVIE\" \u0026\u0026 !seasonUrl.includes(\"film\")) {\n                    return false;\n                }\n                if (opts.media.format !== \"MOVIE\" \u0026\u0026 seasonUrl.includes(\"film\")) {\n                    return false;\n                }\n                \n                if (seasonNumberOpts !== -1) {\n                    const regex = new RegExp(`saison${seasonNumberOpts}(?!\\\\d)`);\n                    if (!seasonUrl.match(regex)) {\n                        return false;\n                    }\n                }\n                \n                return true;\n            });\n\n            if (filteredSeasons.length === 0) {\n                filteredSeasons = seasons;\n            }\n\n            const bestSeason = filteredSeasons[0];\n            \n            let finalUrl = bestSeason.url;\n            if (opts.dub \u0026\u0026 !finalUrl.includes(\"film\")) {\n                const dubUrl = finalUrl.replace(\"/vostfr\", \"/vf\");\n                const dubResponse = await fetch(`${this.SEANIME_API}${encodeURIComponent(dubUrl)}`);\n                if (dubResponse.ok) {\n                    finalUrl = dubUrl;\n                } else {\n                    const vf1Url = dubUrl + \"1\";\n                    const vf1Response = await fetch(`${this.SEANIME_API}${encodeURIComponent(vf1Url)}`);\n                    if (vf1Response.ok) {\n                        finalUrl = vf1Url;\n                    }\n                }\n            }\n\n            return [{\n                id: finalUrl,\n                title: bestSeason.title,\n                url: finalUrl,\n                subOrDub: opts.dub ? \"dub\" : \"sub\",\n            }];\n        }\n\n        return [];\n    }\n\n    async findEpisodes(id: string): Promise\u003cEpisodeDetails[]\u003e {\n        const animeUrl = id.split(\"#\")[0];\n        const movieIndex = id.split(\"#\")[1];\n        \n        const episodesUrl = `${animeUrl}/episodes.js`;\n        const response = await fetch(`${this.SEANIME_API}${encodeURIComponent(episodesUrl)}`);\n        \n        if (!response.ok) {\n            console.error(\"Failed to fetch episodes.js\");\n            return [];\n        }\n        \n        const episodesText = await response.text();\n        const episodeDetails: EpisodeDetails[] = [];\n        const episodeArrays: string[][] = [];\n        \n        for (let i = 0; i \u003c 10; i++) {\n            const regex = new RegExp(`var\\\\s+eps${i}\\\\s*=\\\\s*\\\\[([\\\\s\\\\S]*?)\\\\];`, 'm');\n            const match = regex.exec(episodesText);\n            \n            if (match) {\n                const urls = match[1]\n                    .split(\",\")\n                    .map(url =\u003e url.trim().replace(/['\"]/g, \"\"))\n                    .filter(url =\u003e url \u0026\u0026 url !== \"\");\n                \n                if (urls.length \u003e 0) {\n                    const fixedUrls = urls.map(url =\u003e url.replace(/vidmoly\\.to/g, 'vidmoly.net'));\n                    episodeArrays.push(fixedUrls);\n                }\n            }\n        }\n        \n        if (episodeArrays.length === 0) {\n            return [];\n        }\n        \n        if (movieIndex !== undefined) {\n            const movieIdx = parseInt(movieIndex, 10);\n            const movieUrls: string[] = [];\n            \n            for (const voiceArray of episodeArrays) {\n                if (voiceArray[movieIdx]) {\n                    movieUrls.push(voiceArray[movieIdx]);\n                }\n            }\n            \n            if (movieUrls.length \u003e 0) {\n                return [{\n                    id: movieUrls.join(\",\"),\n                    url: id,\n                    number: 1\n                }];\n            }\n            return [];\n        }\n        \n        const maxEpisodes = Math.max(...episodeArrays.map(arr =\u003e arr.length));\n        \n        for (let episodeIndex = 0; episodeIndex \u003c maxEpisodes; episodeIndex++) {\n            const episodeUrls: string[] = [];\n            \n            for (const voiceArray of episodeArrays) {\n                if (voiceArray[episodeIndex]) {\n                    episodeUrls.push(voiceArray[episodeIndex]);\n                }\n            }\n            \n            if (episodeUrls.length \u003e 0) {\n                episodeDetails.push({\n                    id: episodeUrls.join(\",\"),\n                    url: id,\n                    number: episodeIndex + 1\n                });\n            }\n        }\n        \n        return episodeDetails.reverse();\n    }\n\n    async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise\u003cEpisodeServer\u003e {\n        this._Server = _server;\n        const servers = episode.id.split(\",\");\n        \n        const serverUrl = servers.find(server =\u003e {\n            const parts = server.split(\"/\");\n            const domain = parts[2];\n            if (!domain) return false;\n            \n            const domainParts = domain.split(\".\");\n            const serverName = domainParts.length \u003e= 3 ? domainParts[1] : domainParts[0];\n            return serverName === _server;\n        });\n        \n        if (serverUrl \u0026\u0026 _server !== \"\") {\n            console.log(`Handling server URL: ${serverUrl}`);\n            const videoSources = await this.HandleServerUrl(serverUrl);\n            \n            if (videoSources.length \u003e 0) {\n                const referer = serverUrl.split(\"/\").slice(0, 3).join(\"/\");\n                return {\n                    headers: { referer: referer },\n                    server: _server,\n                    videoSources: videoSources\n                };\n            }\n        }\n\n        console.log(`Server not found: ${_server}`);\n        return {\n            headers: {},\n            server: _server + \" (not found)\",\n            videoSources: [{\n                url: \"https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_fmp4/master.m3u8\",\n                type: \"m3u8\",\n                quality: \"server not found\",\n                subtitles: []\n            }]\n        };\n    }\n}"}
